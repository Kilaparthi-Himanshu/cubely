use std::{f32::consts::E, fs, path::PathBuf};

use serde::{Deserialize, Serialize};

use crate::{commands::server_creation::LoaderType, utils::path::servers_dir};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ServerConfig {
    pub id: String,
    pub name: String,
    pub version: String,
    pub loader: LoaderType,
    pub ram_gb: u8,
    pub path: String,
    pub created_at: i64,
}

#[tauri::command]
pub fn list_servers() -> Result<Vec<ServerConfig>, String> {
    let base = servers_dir();
    let mut servers = Vec::new();

    // First install: no servers directory yet
    if !base.exists() {
        return Ok(servers);
    }

    for version_dir in fs::read_dir(base).map_err(|e| e.to_string())? {
        let version_dir = version_dir.map_err(|e| e.to_string())?;
        if !version_dir.path().is_dir() { continue; } // continue if its not a folder and is a file

        for server_dir in fs::read_dir(version_dir.path()).map_err(|e| e.to_string())? {
            let server_dir = server_dir.map_err(|e| e.to_string())?;
            let config_path = server_dir.path().join("cubely.json");

            if config_path.exists() {
                let content = fs::read_to_string(config_path)
                    .map_err(|e| e.to_string())?;
                let config: ServerConfig = serde_json::from_str(&content)
                    .map_err(|e| e.to_string())?;
                servers.push(config);
            }
        }
    }

    Ok(servers)
}

#[derive(Serialize, Deserialize)]
pub struct ServerProperties {
    pub motd: String,
    pub online_mode: bool,
    pub max_players: u32,
    pub difficulty: String,
    pub gamemode: String,
    pub pvp: bool,
    pub spawn_protection: u32,
    pub view_distance: u32,
    pub simulation_distance: u32,
    pub server_port: u16
}

#[tauri::command]
pub fn read_server_properties(server_path: String) -> Result<ServerProperties, String> {
    let content = fs::read_to_string(
        PathBuf::from(server_path).join("server.properties")
    ).map_err(|e| e.to_string())?;

    let mut map = std::collections::HashMap::new();

    for line in content.lines() {
        let line = line.trim();
        if line.is_empty() || line.starts_with('#') { 
            continue; 
        }

        if let Some((k, v)) = line.split_once('=') {
            map.insert(k.to_string(), v.to_string());
        }
    }

    Ok(ServerProperties {
        motd: map.get("motd").cloned().unwrap_or_default(),
        online_mode: map.get("online-mode").map(|v| v == "true").unwrap_or(true),
        max_players: map.get("max-players").and_then(|v| v.parse().ok()).unwrap_or(20),
        difficulty: map.get("difficulty").cloned().unwrap_or("easy".into()),
        gamemode: map.get("gamemode").cloned().unwrap_or("survival".into()),
        pvp: map.get("pvp").map(|v| v == "true").unwrap_or(true),
        spawn_protection: map.get("spawn-protection").and_then(|v| v.parse().ok()).unwrap_or(16),
        view_distance: map.get("view-distance").and_then(|v| v.parse().ok()).unwrap_or(10),
        simulation_distance: map.get("simulation-distance").and_then(|v| v.parse().ok()).unwrap_or(10),
        server_port: map.get("server-port").and_then(|v| v.parse().ok()).unwrap_or(25565)
    })
}

#[tauri::command]
pub async fn write_server_properties(
    server_path: String,
    props: ServerProperties
) -> Result<(), String> {
    let content = format!(
r#"# Generated by BlockHost
motd={}
online-mode={}
max-players={}
difficulty={}
gamemode={}
pvp={}
spawn-protection={}
view-distance={}
simulation-distance={}
server-port={}
"#,
        props.motd,
        props.online_mode,
        props.max_players,
        props.difficulty,
        props.gamemode,
        props.pvp,
        props.spawn_protection,
        props.view_distance,
        props.simulation_distance,
        props.server_port,
    );

    fs::write(
        PathBuf::from(server_path).join("server.properties"),
        content
    ).map_err(|e| e.to_string())?;

    Ok(())
}
