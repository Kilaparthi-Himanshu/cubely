#![allow(dead_code, unused, unused_imports)]

use chrono::Utc;
use reqwest::Client;
use serde::{ser, Deserialize, Serialize};
use serde_json::Value;
use std::f32::consts::E;
use std::fmt::format;
use std::process::Command;
use std::{fs, path::PathBuf};
use uuid::Uuid;

use crate::commands::server_management::{ServerConfig, TunnelConfig};
use crate::utils::path::{cleanup_empty_parent_dir, cleanup_server_dir, servers_dir};

#[derive(Deserialize, Debug)]
struct VersionDetails {
    downloads: Downloads,
}

#[derive(Deserialize, Debug)]
struct Downloads {
    server: DownloadInfo,
}

#[derive(Deserialize, Debug)]
struct DownloadInfo {
    url: String,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum LoaderType {
    Vanilla,
    Fabric,
    Forge,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CreateServerResult {
    pub success: bool,
    pub path: String,
}

const DEFAULT_SERVER_PROPERTIES: &str = r#"
# Generated by Cubely
enable-command-block=false
gamemode=survival
difficulty=easy
max-players=20
online-mode=true
pvp=true
spawn-protection=16
view-distance=10
simulation-distance=10
level-name=world
motd=A Minecraft Server
server-port=25565
"#;

#[tauri::command]
pub async fn create_server(
    name: String,
    version: String,
    loader: LoaderType,
    ram_gb: u8,
) -> Result<CreateServerResult, String> {
    let mut server_path = servers_dir();
    server_path.push(&version);
    server_path.push(&name);

    if server_path.exists() {
        return Err("Server already exists".into());
    }

    fs::create_dir_all(&server_path).map_err(|e| e.to_string())?;

    let result: Result<(), String> = async {
        match loader {
            LoaderType::Vanilla => {
                create_vanilla_server(&name, &version, &server_path).await?;
            }
            LoaderType::Fabric => {
                create_fabric_server(&version, &server_path).await?;
                fs::create_dir_all(server_path.join("mods")).ok();
            }
            LoaderType::Forge => {
                create_forge_server(&version, &server_path).await?;
                fs::create_dir_all(server_path.join("mods")).ok();
            }
        }

        // Write server.properties and eula only after successful install
        fs::write(
            server_path.join("server.properties"),
            DEFAULT_SERVER_PROPERTIES,
        )
        .map_err(|e| e.to_string())?;
        fs::write(server_path.join("eula.txt"), "eula=true\n").map_err(|e| e.to_string())?;

        Ok(())
    }
    .await;

    // Rollback on failure
    if let Err(err) = result {
        cleanup_server_dir(&server_path);

        if let Some(version_dir) = server_path.parent() {
            cleanup_empty_parent_dir(&version_dir.to_path_buf());
        }

        return Err(err);
    }

    let config = ServerConfig {
        id: Uuid::new_v4().to_string(),
        name: name.to_string(),
        version: version.to_string(),
        loader,
        ram_gb,
        path: server_path.to_string_lossy().to_string(),
        created_at: Utc::now().timestamp(),
        tunnel: Some(TunnelConfig {
            enabled: false,
            provider: "ngrok".into(),
        }),
    };

    fs::write(
        server_path.join("cubely.json"),
        serde_json::to_string_pretty(&config).unwrap(),
    )
    .map_err(|e| e.to_string())?;

    Ok(CreateServerResult {
        success: true,
        path: server_path.to_string_lossy().to_string(),
    })
}

pub async fn create_vanilla_server(
    name: &str,
    version: &str,
    server_path: &PathBuf,
) -> Result<(), String> {
    // Fetch version manifest
    let client = Client::new();

    let manifest: serde_json::Value = client
        .get("https://launchermeta.mojang.com/mc/game/version_manifest.json")
        .send()
        .await
        .map_err(|e| e.to_string())?
        .json()
        .await
        .map_err(|e| e.to_string())?;

    let versions = manifest["versions"].as_array().ok_or("Invalid Manifest")?;

    // Find the selected version
    let version_url = versions
        .iter()
        .find(|v| v["id"] == version)
        .and_then(|v| v["url"].as_str())
        .ok_or("Version not found")?;

    // Fetch version details
    let details: VersionDetails = client
        .get(version_url)
        .send()
        .await
        .map_err(|e| e.to_string())?
        .json()
        .await
        .map_err(|e| e.to_string())?;

    println!("{:?}", details);

    // Extract server download URL
    let server_url = details.downloads.server.url;

    // Download server.jar
    let jar_path = server_path.join("server.jar");
    let bytes = client
        .get(server_url)
        .send()
        .await
        .map_err(|e| e.to_string())?
        .bytes()
        .await
        .map_err(|e| e.to_string())?;

    fs::write(&jar_path, bytes).map_err(|e| e.to_string())?;

    Ok(())
}

pub async fn create_fabric_server(version: &str, server_path: &PathBuf) -> Result<(), String> {
    let client = Client::new();

    // Fetch latest Fabric installer info
    let installers: Value = client
        .get("https://meta.fabricmc.net/v2/versions/installer")
        .send()
        .await
        .map_err(|e| format!("Failed to fetch Fabric installer list: {}", e))?
        .json()
        .await
        .map_err(|e| format!("Failed to parse Fabric installer list: {}", e))?;

    let installer = installers
        .as_array()
        .and_then(|arr| arr.first())
        .ok_or("No Fabric installer versions found")?;

    let installer_version = installer["version"]
        .as_str()
        .ok_or("Invalid Fabric installer version")?;

    let installer_url = format!(
        "https://maven.fabricmc.net/net/fabricmc/fabric-installer/{0}/fabric-installer-{0}.jar",
        installer_version
    );

    // Download Fabric installer
    let installer_path = server_path.join("fabric-installer.jar");

    let bytes = client
        .get(&installer_url)
        .send()
        .await
        .map_err(|e| format!("Failed to download Fabric installer: {}", e))?
        .bytes()
        .await
        .map_err(|e| format!("Failed to read Fabric installer bytes: {}", e))?;

    fs::write(&installer_path, bytes)
        .map_err(|e| format!("Failed to write Fabric installer: {}", e))?;

    // Run Fabric installer
    let status = Command::new("java")
        .arg("-jar")
        .arg("fabric-installer.jar")
        .arg("server")
        .arg("-mcversion")
        .arg(version)
        .arg("-downloadMinecraft")
        .current_dir(server_path)
        .status()
        .map_err(|e| format!("Failed to run Fabric installer (is Java installed?): {}", e))?;

    // java -jar fabric-installer.jar server \
    //     -mcversion 1.21.1 \
    //     -downloadMinecraft

    if !status.success() {
        return Err("Fabric installer failed".into());
    }

    fs::remove_file(installer_path).ok();

    Ok(())
}

pub async fn create_forge_server(version: &str, server_path: &PathBuf) -> Result<(), String> {
    let client = Client::new();

    // Resolve real Forge version
    let forge_version = resolve_latest_forge_build(version).await?;

    // Build Forge installer URL
    let installer_url = format!(
        "https://maven.minecraftforge.net/net/minecraftforge/forge/{0}/forge-{0}-installer.jar",
        forge_version
    );

    let installer_path = server_path.join("forge-installer.jar");

    // Download Forge installer
    let bytes = client
        .get(&installer_url)
        .send()
        .await
        .map_err(|e| format!("Failed to download Forge installer: {}", e))?
        .bytes()
        .await
        .map_err(|e| format!("Failed to read Forge installer bytes: {}", e))?;

    // Safety check
    if bytes.len() < 1_000_000 {
        return Err(format!(
            "Invalid Forge installer downloaded for {}",
            forge_version
        ));
    }

    println!("Downloaded forge installer size: {} bytes", bytes.len());

    fs::write(&installer_path, bytes)
        .map_err(|e| format!("Failed to write Forge installer: {}", e))?;

    // Run Forge installer
    let status = Command::new("java")
        .arg("-jar")
        .arg("forge-installer.jar")
        .arg("--installServer")
        .current_dir(server_path)
        .status()
        .map_err(|e| format!("Failed to run Forge installer (is Java installed?): {}", e))?;

    if !status.success() {
        return Err("Forge installer failed".into());
    }

    fs::remove_file(installer_path).ok();

    Ok(())
}

async fn resolve_latest_forge_build(version: &str) -> Result<String, String> {
    let text = reqwest::get(
        "https://maven.minecraftforge.net/net/minecraftforge/forge/maven-metadata.xml",
    )
    .await
    .map_err(|e| e.to_string())?
    .text()
    .await
    .map_err(|e| e.to_string())?;

    for line in text.lines() {
        let line = line.trim();

        if line.starts_with("<version>") && line.ends_with("</version>") {
            let full = line.replace("<version>", "").replace("</version>", "");

            let parts: Vec<&str> = full.splitn(2, '-').collect();
            let mc_version = parts[0];

            if mc_version == version {
                return Ok(full);
            }
        }
    }

    Err(format!("No Forge build found for Minecraft {}", version))
}
